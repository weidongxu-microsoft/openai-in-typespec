// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.openai.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Map;

/**
 * Represents an execution run on a [thread](/docs/api-reference/threads).
 */
@Immutable
public final class RunObject implements JsonSerializable<RunObject> {
    /*
     * The identifier, which can be referenced in API endpoints.
     */
    @Generated
    private final String id;

    /*
     * The object type, which is always `thread.run`.
     */
    @Generated
    private final String object = "thread.run";

    /*
     * The Unix timestamp (in seconds) for when the run was created.
     */
    @Generated
    private final long createdAt;

    /*
     * The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
     */
    @Generated
    private final String threadId;

    /*
     * The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
     */
    @Generated
    private final String assistantId;

    /*
     * The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`,
     * `failed`, `completed`, `incomplete`, or `expired`.
     */
    @Generated
    private final RunObjectStatus status;

    /*
     * Details on the action required to continue the run. Will be `null` if no action is required.
     */
    @Generated
    private final RunObjectRequiredAction requiredAction;

    /*
     * The last error associated with this run. Will be `null` if there are no errors.
     */
    @Generated
    private final RunObjectLastError lastError;

    /*
     * The Unix timestamp (in seconds) for when the run will expire.
     */
    @Generated
    private final Long expiresAt;

    /*
     * The Unix timestamp (in seconds) for when the run was started.
     */
    @Generated
    private final Long startedAt;

    /*
     * The Unix timestamp (in seconds) for when the run was cancelled.
     */
    @Generated
    private final Long cancelledAt;

    /*
     * The Unix timestamp (in seconds) for when the run failed.
     */
    @Generated
    private final Long failedAt;

    /*
     * The Unix timestamp (in seconds) for when the run was completed.
     */
    @Generated
    private final Long completedAt;

    /*
     * Details on why the run is incomplete. Will be `null` if the run is not incomplete.
     */
    @Generated
    private final RunObjectIncompleteDetails incompleteDetails;

    /*
     * The model that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    @Generated
    private final String model;

    /*
     * The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    @Generated
    private final String instructions;

    /*
     * The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    @Generated
    private final List<AssistantToolDefinition> tools;

    /*
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
     * information about the object in a structured format. Keys can be a maximum of 64 characters long and values can
     * be a maximum of 512 characters long.
     */
    @Generated
    private final Map<String, String> metadata;

    /*
     * The usage property.
     */
    @Generated
    private final RunCompletionUsage usage;

    /*
     * The sampling temperature used for this run. If not set, defaults to 1.
     */
    @Generated
    private Double temperature;

    /*
     * The nucleus sampling value used for this run. If not set, defaults to 1.
     */
    @Generated
    private Double topP;

    /*
     * The maximum number of prompt tokens specified to have been used over the course of the run.
     */
    @Generated
    private final Integer maxPromptTokens;

    /*
     * The maximum number of completion tokens specified to have been used over the course of the run.
     */
    @Generated
    private final Integer maxCompletionTokens;

    /*
     * The truncation_strategy property.
     */
    @Generated
    private final TruncationObject truncationStrategy;

    /*
     * The tool_choice property.
     */
    @Generated
    private final BinaryData toolChoice;

    /*
     * The parallel_tool_calls property.
     */
    @Generated
    private final boolean parallelToolCalls;

    /*
     * The response_format property.
     */
    @Generated
    private final BinaryData responseFormat;

    /**
     * Creates an instance of RunObject class.
     * 
     * @param id the id value to set.
     * @param createdAt the createdAt value to set.
     * @param threadId the threadId value to set.
     * @param assistantId the assistantId value to set.
     * @param status the status value to set.
     * @param requiredAction the requiredAction value to set.
     * @param lastError the lastError value to set.
     * @param expiresAt the expiresAt value to set.
     * @param startedAt the startedAt value to set.
     * @param cancelledAt the cancelledAt value to set.
     * @param failedAt the failedAt value to set.
     * @param completedAt the completedAt value to set.
     * @param incompleteDetails the incompleteDetails value to set.
     * @param model the model value to set.
     * @param instructions the instructions value to set.
     * @param tools the tools value to set.
     * @param metadata the metadata value to set.
     * @param usage the usage value to set.
     * @param maxPromptTokens the maxPromptTokens value to set.
     * @param maxCompletionTokens the maxCompletionTokens value to set.
     * @param truncationStrategy the truncationStrategy value to set.
     * @param toolChoice the toolChoice value to set.
     * @param parallelToolCalls the parallelToolCalls value to set.
     * @param responseFormat the responseFormat value to set.
     */
    @Generated
    private RunObject(String id, OffsetDateTime createdAt, String threadId, String assistantId, RunObjectStatus status,
        RunObjectRequiredAction requiredAction, RunObjectLastError lastError, OffsetDateTime expiresAt,
        OffsetDateTime startedAt, OffsetDateTime cancelledAt, OffsetDateTime failedAt, OffsetDateTime completedAt,
        RunObjectIncompleteDetails incompleteDetails, String model, String instructions,
        List<AssistantToolDefinition> tools, Map<String, String> metadata, RunCompletionUsage usage,
        Integer maxPromptTokens, Integer maxCompletionTokens, TruncationObject truncationStrategy,
        BinaryData toolChoice, boolean parallelToolCalls, BinaryData responseFormat) {
        this.id = id;
        if (createdAt == null) {
            this.createdAt = 0L;
        } else {
            this.createdAt = createdAt.toEpochSecond();
        }
        this.threadId = threadId;
        this.assistantId = assistantId;
        this.status = status;
        this.requiredAction = requiredAction;
        this.lastError = lastError;
        if (expiresAt == null) {
            this.expiresAt = null;
        } else {
            this.expiresAt = expiresAt.toEpochSecond();
        }
        if (startedAt == null) {
            this.startedAt = null;
        } else {
            this.startedAt = startedAt.toEpochSecond();
        }
        if (cancelledAt == null) {
            this.cancelledAt = null;
        } else {
            this.cancelledAt = cancelledAt.toEpochSecond();
        }
        if (failedAt == null) {
            this.failedAt = null;
        } else {
            this.failedAt = failedAt.toEpochSecond();
        }
        if (completedAt == null) {
            this.completedAt = null;
        } else {
            this.completedAt = completedAt.toEpochSecond();
        }
        this.incompleteDetails = incompleteDetails;
        this.model = model;
        this.instructions = instructions;
        this.tools = tools;
        this.metadata = metadata;
        this.usage = usage;
        this.maxPromptTokens = maxPromptTokens;
        this.maxCompletionTokens = maxCompletionTokens;
        this.truncationStrategy = truncationStrategy;
        this.toolChoice = toolChoice;
        this.parallelToolCalls = parallelToolCalls;
        this.responseFormat = responseFormat;
    }

    /**
     * Get the id property: The identifier, which can be referenced in API endpoints.
     * 
     * @return the id value.
     */
    @Generated
    public String getId() {
        return this.id;
    }

    /**
     * Get the object property: The object type, which is always `thread.run`.
     * 
     * @return the object value.
     */
    @Generated
    public String getObject() {
        return this.object;
    }

    /**
     * Get the createdAt property: The Unix timestamp (in seconds) for when the run was created.
     * 
     * @return the createdAt value.
     */
    @Generated
    public OffsetDateTime getCreatedAt() {
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.createdAt), ZoneOffset.UTC);
    }

    /**
     * Get the threadId property: The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of
     * this run.
     * 
     * @return the threadId value.
     */
    @Generated
    public String getThreadId() {
        return this.threadId;
    }

    /**
     * Get the assistantId property: The ID of the [assistant](/docs/api-reference/assistants) used for execution of
     * this run.
     * 
     * @return the assistantId value.
     */
    @Generated
    public String getAssistantId() {
        return this.assistantId;
    }

    /**
     * Get the status property: The status of the run, which can be either `queued`, `in_progress`, `requires_action`,
     * `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
     * 
     * @return the status value.
     */
    @Generated
    public RunObjectStatus getStatus() {
        return this.status;
    }

    /**
     * Get the requiredAction property: Details on the action required to continue the run. Will be `null` if no action
     * is required.
     * 
     * @return the requiredAction value.
     */
    @Generated
    public RunObjectRequiredAction getRequiredAction() {
        return this.requiredAction;
    }

    /**
     * Get the lastError property: The last error associated with this run. Will be `null` if there are no errors.
     * 
     * @return the lastError value.
     */
    @Generated
    public RunObjectLastError getLastError() {
        return this.lastError;
    }

    /**
     * Get the expiresAt property: The Unix timestamp (in seconds) for when the run will expire.
     * 
     * @return the expiresAt value.
     */
    @Generated
    public OffsetDateTime getExpiresAt() {
        if (this.expiresAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.expiresAt), ZoneOffset.UTC);
    }

    /**
     * Get the startedAt property: The Unix timestamp (in seconds) for when the run was started.
     * 
     * @return the startedAt value.
     */
    @Generated
    public OffsetDateTime getStartedAt() {
        if (this.startedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.startedAt), ZoneOffset.UTC);
    }

    /**
     * Get the cancelledAt property: The Unix timestamp (in seconds) for when the run was cancelled.
     * 
     * @return the cancelledAt value.
     */
    @Generated
    public OffsetDateTime getCancelledAt() {
        if (this.cancelledAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.cancelledAt), ZoneOffset.UTC);
    }

    /**
     * Get the failedAt property: The Unix timestamp (in seconds) for when the run failed.
     * 
     * @return the failedAt value.
     */
    @Generated
    public OffsetDateTime getFailedAt() {
        if (this.failedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.failedAt), ZoneOffset.UTC);
    }

    /**
     * Get the completedAt property: The Unix timestamp (in seconds) for when the run was completed.
     * 
     * @return the completedAt value.
     */
    @Generated
    public OffsetDateTime getCompletedAt() {
        if (this.completedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.completedAt), ZoneOffset.UTC);
    }

    /**
     * Get the incompleteDetails property: Details on why the run is incomplete. Will be `null` if the run is not
     * incomplete.
     * 
     * @return the incompleteDetails value.
     */
    @Generated
    public RunObjectIncompleteDetails getIncompleteDetails() {
        return this.incompleteDetails;
    }

    /**
     * Get the model property: The model that the [assistant](/docs/api-reference/assistants) used for this run.
     * 
     * @return the model value.
     */
    @Generated
    public String getModel() {
        return this.model;
    }

    /**
     * Get the instructions property: The instructions that the [assistant](/docs/api-reference/assistants) used for
     * this run.
     * 
     * @return the instructions value.
     */
    @Generated
    public String getInstructions() {
        return this.instructions;
    }

    /**
     * Get the tools property: The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     * 
     * @return the tools value.
     */
    @Generated
    public List<AssistantToolDefinition> getTools() {
        return this.tools;
    }

    /**
     * Get the metadata property: Set of 16 key-value pairs that can be attached to an object. This can be useful for
     * storing additional information about the object in a structured format. Keys can be a maximum of 64 characters
     * long and values can be a maximum of 512 characters long.
     * 
     * @return the metadata value.
     */
    @Generated
    public Map<String, String> getMetadata() {
        return this.metadata;
    }

    /**
     * Get the usage property: The usage property.
     * 
     * @return the usage value.
     */
    @Generated
    public RunCompletionUsage getUsage() {
        return this.usage;
    }

    /**
     * Get the temperature property: The sampling temperature used for this run. If not set, defaults to 1.
     * 
     * @return the temperature value.
     */
    @Generated
    public Double getTemperature() {
        return this.temperature;
    }

    /**
     * Get the topP property: The nucleus sampling value used for this run. If not set, defaults to 1.
     * 
     * @return the topP value.
     */
    @Generated
    public Double getTopP() {
        return this.topP;
    }

    /**
     * Get the maxPromptTokens property: The maximum number of prompt tokens specified to have been used over the course
     * of the run.
     * 
     * @return the maxPromptTokens value.
     */
    @Generated
    public Integer getMaxPromptTokens() {
        return this.maxPromptTokens;
    }

    /**
     * Get the maxCompletionTokens property: The maximum number of completion tokens specified to have been used over
     * the course of the run.
     * 
     * @return the maxCompletionTokens value.
     */
    @Generated
    public Integer getMaxCompletionTokens() {
        return this.maxCompletionTokens;
    }

    /**
     * Get the truncationStrategy property: The truncation_strategy property.
     * 
     * @return the truncationStrategy value.
     */
    @Generated
    public TruncationObject getTruncationStrategy() {
        return this.truncationStrategy;
    }

    /**
     * Get the toolChoice property: The tool_choice property.
     * 
     * @return the toolChoice value.
     */
    @Generated
    public BinaryData getToolChoice() {
        return this.toolChoice;
    }

    /**
     * Get the parallelToolCalls property: The parallel_tool_calls property.
     * 
     * @return the parallelToolCalls value.
     */
    @Generated
    public boolean isParallelToolCalls() {
        return this.parallelToolCalls;
    }

    /**
     * Get the responseFormat property: The response_format property.
     * 
     * @return the responseFormat value.
     */
    @Generated
    public BinaryData getResponseFormat() {
        return this.responseFormat;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("id", this.id);
        jsonWriter.writeStringField("object", this.object);
        jsonWriter.writeLongField("created_at", this.createdAt);
        jsonWriter.writeStringField("thread_id", this.threadId);
        jsonWriter.writeStringField("assistant_id", this.assistantId);
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeJsonField("required_action", this.requiredAction);
        jsonWriter.writeJsonField("last_error", this.lastError);
        jsonWriter.writeNumberField("expires_at", this.expiresAt);
        jsonWriter.writeNumberField("started_at", this.startedAt);
        jsonWriter.writeNumberField("cancelled_at", this.cancelledAt);
        jsonWriter.writeNumberField("failed_at", this.failedAt);
        jsonWriter.writeNumberField("completed_at", this.completedAt);
        jsonWriter.writeJsonField("incomplete_details", this.incompleteDetails);
        jsonWriter.writeStringField("model", this.model);
        jsonWriter.writeStringField("instructions", this.instructions);
        jsonWriter.writeArrayField("tools", this.tools, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeMapField("metadata", this.metadata, (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("usage", this.usage);
        jsonWriter.writeNumberField("max_prompt_tokens", this.maxPromptTokens);
        jsonWriter.writeNumberField("max_completion_tokens", this.maxCompletionTokens);
        jsonWriter.writeJsonField("truncation_strategy", this.truncationStrategy);
        jsonWriter.writeUntypedField("tool_choice", this.toolChoice.toObject(Object.class));
        jsonWriter.writeBooleanField("parallel_tool_calls", this.parallelToolCalls);
        jsonWriter.writeUntypedField("response_format", this.responseFormat.toObject(Object.class));
        jsonWriter.writeNumberField("temperature", this.temperature);
        jsonWriter.writeNumberField("top_p", this.topP);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RunObject from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of RunObject if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the RunObject.
     */
    @Generated
    public static RunObject fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String id = null;
            OffsetDateTime createdAt = null;
            String threadId = null;
            String assistantId = null;
            RunObjectStatus status = null;
            RunObjectRequiredAction requiredAction = null;
            RunObjectLastError lastError = null;
            OffsetDateTime expiresAt = null;
            OffsetDateTime startedAt = null;
            OffsetDateTime cancelledAt = null;
            OffsetDateTime failedAt = null;
            OffsetDateTime completedAt = null;
            RunObjectIncompleteDetails incompleteDetails = null;
            String model = null;
            String instructions = null;
            List<AssistantToolDefinition> tools = null;
            Map<String, String> metadata = null;
            RunCompletionUsage usage = null;
            Integer maxPromptTokens = null;
            Integer maxCompletionTokens = null;
            TruncationObject truncationStrategy = null;
            BinaryData toolChoice = null;
            boolean parallelToolCalls = false;
            BinaryData responseFormat = null;
            Double temperature = null;
            Double topP = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    id = reader.getString();
                } else if ("created_at".equals(fieldName)) {
                    createdAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(reader.getLong()), ZoneOffset.UTC);
                } else if ("thread_id".equals(fieldName)) {
                    threadId = reader.getString();
                } else if ("assistant_id".equals(fieldName)) {
                    assistantId = reader.getString();
                } else if ("status".equals(fieldName)) {
                    status = RunObjectStatus.fromString(reader.getString());
                } else if ("required_action".equals(fieldName)) {
                    requiredAction = RunObjectRequiredAction.fromJson(reader);
                } else if ("last_error".equals(fieldName)) {
                    lastError = RunObjectLastError.fromJson(reader);
                } else if ("expires_at".equals(fieldName)) {
                    Long expiresAtHolder = reader.getNullable(JsonReader::getLong);
                    if (expiresAtHolder != null) {
                        expiresAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(expiresAtHolder), ZoneOffset.UTC);
                    }
                } else if ("started_at".equals(fieldName)) {
                    Long startedAtHolder = reader.getNullable(JsonReader::getLong);
                    if (startedAtHolder != null) {
                        startedAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(startedAtHolder), ZoneOffset.UTC);
                    }
                } else if ("cancelled_at".equals(fieldName)) {
                    Long cancelledAtHolder = reader.getNullable(JsonReader::getLong);
                    if (cancelledAtHolder != null) {
                        cancelledAt
                            = OffsetDateTime.ofInstant(Instant.ofEpochSecond(cancelledAtHolder), ZoneOffset.UTC);
                    }
                } else if ("failed_at".equals(fieldName)) {
                    Long failedAtHolder = reader.getNullable(JsonReader::getLong);
                    if (failedAtHolder != null) {
                        failedAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(failedAtHolder), ZoneOffset.UTC);
                    }
                } else if ("completed_at".equals(fieldName)) {
                    Long completedAtHolder = reader.getNullable(JsonReader::getLong);
                    if (completedAtHolder != null) {
                        completedAt
                            = OffsetDateTime.ofInstant(Instant.ofEpochSecond(completedAtHolder), ZoneOffset.UTC);
                    }
                } else if ("incomplete_details".equals(fieldName)) {
                    incompleteDetails = RunObjectIncompleteDetails.fromJson(reader);
                } else if ("model".equals(fieldName)) {
                    model = reader.getString();
                } else if ("instructions".equals(fieldName)) {
                    instructions = reader.getString();
                } else if ("tools".equals(fieldName)) {
                    tools = reader.readArray(reader1 -> AssistantToolDefinition.fromJson(reader1));
                } else if ("metadata".equals(fieldName)) {
                    metadata = reader.readMap(reader1 -> reader1.getString());
                } else if ("usage".equals(fieldName)) {
                    usage = RunCompletionUsage.fromJson(reader);
                } else if ("max_prompt_tokens".equals(fieldName)) {
                    maxPromptTokens = reader.getNullable(JsonReader::getInt);
                } else if ("max_completion_tokens".equals(fieldName)) {
                    maxCompletionTokens = reader.getNullable(JsonReader::getInt);
                } else if ("truncation_strategy".equals(fieldName)) {
                    truncationStrategy = TruncationObject.fromJson(reader);
                } else if ("tool_choice".equals(fieldName)) {
                    toolChoice
                        = reader.getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()));
                } else if ("parallel_tool_calls".equals(fieldName)) {
                    parallelToolCalls = reader.getBoolean();
                } else if ("response_format".equals(fieldName)) {
                    responseFormat
                        = reader.getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()));
                } else if ("temperature".equals(fieldName)) {
                    temperature = reader.getNullable(JsonReader::getDouble);
                } else if ("top_p".equals(fieldName)) {
                    topP = reader.getNullable(JsonReader::getDouble);
                } else {
                    reader.skipChildren();
                }
            }
            RunObject deserializedRunObject = new RunObject(id, createdAt, threadId, assistantId, status,
                requiredAction, lastError, expiresAt, startedAt, cancelledAt, failedAt, completedAt, incompleteDetails,
                model, instructions, tools, metadata, usage, maxPromptTokens, maxCompletionTokens, truncationStrategy,
                toolChoice, parallelToolCalls, responseFormat);
            deserializedRunObject.temperature = temperature;
            deserializedRunObject.topP = topP;

            return deserializedRunObject;
        });
    }
}
