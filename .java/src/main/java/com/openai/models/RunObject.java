// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.openai.models;

import io.clientcore.core.annotation.Metadata;
import io.clientcore.core.annotation.TypeConditions;
import io.clientcore.core.json.JsonReader;
import io.clientcore.core.json.JsonSerializable;
import io.clientcore.core.json.JsonToken;
import io.clientcore.core.json.JsonWriter;
import io.clientcore.core.util.binarydata.BinaryData;
import java.io.IOException;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Map;

/**
 * Represents an execution run on a [thread](/docs/api-reference/threads).
 */
@Metadata(conditions = { TypeConditions.IMMUTABLE })
public final class RunObject implements JsonSerializable<RunObject> {
    /*
     * The identifier, which can be referenced in API endpoints.
     */
    @Metadata(generated = true)
    private final String id;

    /*
     * The object type, which is always `thread.run`.
     */
    @Metadata(generated = true)
    private final String object = "thread.run";

    /*
     * The Unix timestamp (in seconds) for when the run was created.
     */
    @Metadata(generated = true)
    private final long createdAt;

    /*
     * The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
     */
    @Metadata(generated = true)
    private final String threadId;

    /*
     * The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
     */
    @Metadata(generated = true)
    private final String assistantId;

    /*
     * The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`,
     * `failed`, `completed`, `incomplete`, or `expired`.
     */
    @Metadata(generated = true)
    private final RunObjectStatus status;

    /*
     * Details on the action required to continue the run. Will be `null` if no action is required.
     */
    @Metadata(generated = true)
    private final RunObjectRequiredAction requiredAction;

    /*
     * The last error associated with this run. Will be `null` if there are no errors.
     */
    @Metadata(generated = true)
    private final RunObjectLastError lastError;

    /*
     * The Unix timestamp (in seconds) for when the run will expire.
     */
    @Metadata(generated = true)
    private final Long expiresAt;

    /*
     * The Unix timestamp (in seconds) for when the run was started.
     */
    @Metadata(generated = true)
    private final Long startedAt;

    /*
     * The Unix timestamp (in seconds) for when the run was cancelled.
     */
    @Metadata(generated = true)
    private final Long cancelledAt;

    /*
     * The Unix timestamp (in seconds) for when the run failed.
     */
    @Metadata(generated = true)
    private final Long failedAt;

    /*
     * The Unix timestamp (in seconds) for when the run was completed.
     */
    @Metadata(generated = true)
    private final Long completedAt;

    /*
     * Details on why the run is incomplete. Will be `null` if the run is not incomplete.
     */
    @Metadata(generated = true)
    private final RunObjectIncompleteDetails incompleteDetails;

    /*
     * The model that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    @Metadata(generated = true)
    private final String model;

    /*
     * The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    @Metadata(generated = true)
    private final String instructions;

    /*
     * The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    @Metadata(generated = true)
    private final List<AssistantToolDefinition> tools;

    /*
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
     * information about the object in a structured format. Keys can be a maximum of 64 characters long and values can
     * be a maximum of 512 characters long.
     */
    @Metadata(generated = true)
    private final Map<String, String> metadata;

    /*
     * The usage property.
     */
    @Metadata(generated = true)
    private final RunCompletionUsage usage;

    /*
     * The sampling temperature used for this run. If not set, defaults to 1.
     */
    @Metadata(generated = true)
    private Double temperature;

    /*
     * The nucleus sampling value used for this run. If not set, defaults to 1.
     */
    @Metadata(generated = true)
    private Double topP;

    /*
     * The maximum number of prompt tokens specified to have been used over the course of the run.
     */
    @Metadata(generated = true)
    private final Integer maxPromptTokens;

    /*
     * The maximum number of completion tokens specified to have been used over the course of the run.
     */
    @Metadata(generated = true)
    private final Integer maxCompletionTokens;

    /*
     * The truncation_strategy property.
     */
    @Metadata(generated = true)
    private final TruncationObject truncationStrategy;

    /*
     * The tool_choice property.
     */
    @Metadata(generated = true)
    private final BinaryData toolChoice;

    /*
     * The parallel_tool_calls property.
     */
    @Metadata(generated = true)
    private final boolean parallelToolCalls;

    /*
     * The response_format property.
     */
    @Metadata(generated = true)
    private final BinaryData responseFormat;

    /**
     * Creates an instance of RunObject class.
     * 
     * @param id the id value to set.
     * @param createdAt the createdAt value to set.
     * @param threadId the threadId value to set.
     * @param assistantId the assistantId value to set.
     * @param status the status value to set.
     * @param requiredAction the requiredAction value to set.
     * @param lastError the lastError value to set.
     * @param expiresAt the expiresAt value to set.
     * @param startedAt the startedAt value to set.
     * @param cancelledAt the cancelledAt value to set.
     * @param failedAt the failedAt value to set.
     * @param completedAt the completedAt value to set.
     * @param incompleteDetails the incompleteDetails value to set.
     * @param model the model value to set.
     * @param instructions the instructions value to set.
     * @param tools the tools value to set.
     * @param metadata the metadata value to set.
     * @param usage the usage value to set.
     * @param maxPromptTokens the maxPromptTokens value to set.
     * @param maxCompletionTokens the maxCompletionTokens value to set.
     * @param truncationStrategy the truncationStrategy value to set.
     * @param toolChoice the toolChoice value to set.
     * @param parallelToolCalls the parallelToolCalls value to set.
     * @param responseFormat the responseFormat value to set.
     */
    @Metadata(generated = true)
    private RunObject(String id, OffsetDateTime createdAt, String threadId, String assistantId, RunObjectStatus status,
        RunObjectRequiredAction requiredAction, RunObjectLastError lastError, OffsetDateTime expiresAt,
        OffsetDateTime startedAt, OffsetDateTime cancelledAt, OffsetDateTime failedAt, OffsetDateTime completedAt,
        RunObjectIncompleteDetails incompleteDetails, String model, String instructions,
        List<AssistantToolDefinition> tools, Map<String, String> metadata, RunCompletionUsage usage,
        Integer maxPromptTokens, Integer maxCompletionTokens, TruncationObject truncationStrategy,
        BinaryData toolChoice, boolean parallelToolCalls, BinaryData responseFormat) {
        this.id = id;
        if (createdAt == null) {
            this.createdAt = 0L;
        } else {
            this.createdAt = createdAt.toEpochSecond();
        }
        this.threadId = threadId;
        this.assistantId = assistantId;
        this.status = status;
        this.requiredAction = requiredAction;
        this.lastError = lastError;
        if (expiresAt == null) {
            this.expiresAt = null;
        } else {
            this.expiresAt = expiresAt.toEpochSecond();
        }
        if (startedAt == null) {
            this.startedAt = null;
        } else {
            this.startedAt = startedAt.toEpochSecond();
        }
        if (cancelledAt == null) {
            this.cancelledAt = null;
        } else {
            this.cancelledAt = cancelledAt.toEpochSecond();
        }
        if (failedAt == null) {
            this.failedAt = null;
        } else {
            this.failedAt = failedAt.toEpochSecond();
        }
        if (completedAt == null) {
            this.completedAt = null;
        } else {
            this.completedAt = completedAt.toEpochSecond();
        }
        this.incompleteDetails = incompleteDetails;
        this.model = model;
        this.instructions = instructions;
        this.tools = tools;
        this.metadata = metadata;
        this.usage = usage;
        this.maxPromptTokens = maxPromptTokens;
        this.maxCompletionTokens = maxCompletionTokens;
        this.truncationStrategy = truncationStrategy;
        this.toolChoice = toolChoice;
        this.parallelToolCalls = parallelToolCalls;
        this.responseFormat = responseFormat;
    }

    /**
     * Get the id property: The identifier, which can be referenced in API endpoints.
     * 
     * @return the id value.
     */
    @Metadata(generated = true)
    public String getId() {
        return this.id;
    }

    /**
     * Get the object property: The object type, which is always `thread.run`.
     * 
     * @return the object value.
     */
    @Metadata(generated = true)
    public String getObject() {
        return this.object;
    }

    /**
     * Get the createdAt property: The Unix timestamp (in seconds) for when the run was created.
     * 
     * @return the createdAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCreatedAt() {
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.createdAt), ZoneOffset.UTC);
    }

    /**
     * Get the threadId property: The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of
     * this run.
     * 
     * @return the threadId value.
     */
    @Metadata(generated = true)
    public String getThreadId() {
        return this.threadId;
    }

    /**
     * Get the assistantId property: The ID of the [assistant](/docs/api-reference/assistants) used for execution of
     * this run.
     * 
     * @return the assistantId value.
     */
    @Metadata(generated = true)
    public String getAssistantId() {
        return this.assistantId;
    }

    /**
     * Get the status property: The status of the run, which can be either `queued`, `in_progress`, `requires_action`,
     * `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
     * 
     * @return the status value.
     */
    @Metadata(generated = true)
    public RunObjectStatus getStatus() {
        return this.status;
    }

    /**
     * Get the requiredAction property: Details on the action required to continue the run. Will be `null` if no action
     * is required.
     * 
     * @return the requiredAction value.
     */
    @Metadata(generated = true)
    public RunObjectRequiredAction getRequiredAction() {
        return this.requiredAction;
    }

    /**
     * Get the lastError property: The last error associated with this run. Will be `null` if there are no errors.
     * 
     * @return the lastError value.
     */
    @Metadata(generated = true)
    public RunObjectLastError getLastError() {
        return this.lastError;
    }

    /**
     * Get the expiresAt property: The Unix timestamp (in seconds) for when the run will expire.
     * 
     * @return the expiresAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getExpiresAt() {
        if (this.expiresAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.expiresAt), ZoneOffset.UTC);
    }

    /**
     * Get the startedAt property: The Unix timestamp (in seconds) for when the run was started.
     * 
     * @return the startedAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getStartedAt() {
        if (this.startedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.startedAt), ZoneOffset.UTC);
    }

    /**
     * Get the cancelledAt property: The Unix timestamp (in seconds) for when the run was cancelled.
     * 
     * @return the cancelledAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCancelledAt() {
        if (this.cancelledAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.cancelledAt), ZoneOffset.UTC);
    }

    /**
     * Get the failedAt property: The Unix timestamp (in seconds) for when the run failed.
     * 
     * @return the failedAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getFailedAt() {
        if (this.failedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.failedAt), ZoneOffset.UTC);
    }

    /**
     * Get the completedAt property: The Unix timestamp (in seconds) for when the run was completed.
     * 
     * @return the completedAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCompletedAt() {
        if (this.completedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.completedAt), ZoneOffset.UTC);
    }

    /**
     * Get the incompleteDetails property: Details on why the run is incomplete. Will be `null` if the run is not
     * incomplete.
     * 
     * @return the incompleteDetails value.
     */
    @Metadata(generated = true)
    public RunObjectIncompleteDetails getIncompleteDetails() {
        return this.incompleteDetails;
    }

    /**
     * Get the model property: The model that the [assistant](/docs/api-reference/assistants) used for this run.
     * 
     * @return the model value.
     */
    @Metadata(generated = true)
    public String getModel() {
        return this.model;
    }

    /**
     * Get the instructions property: The instructions that the [assistant](/docs/api-reference/assistants) used for
     * this run.
     * 
     * @return the instructions value.
     */
    @Metadata(generated = true)
    public String getInstructions() {
        return this.instructions;
    }

    /**
     * Get the tools property: The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     * 
     * @return the tools value.
     */
    @Metadata(generated = true)
    public List<AssistantToolDefinition> getTools() {
        return this.tools;
    }

    /**
     * Get the metadata property: Set of 16 key-value pairs that can be attached to an object. This can be useful for
     * storing additional information about the object in a structured format. Keys can be a maximum of 64 characters
     * long and values can be a maximum of 512 characters long.
     * 
     * @return the metadata value.
     */
    @Metadata(generated = true)
    public Map<String, String> getMetadata() {
        return this.metadata;
    }

    /**
     * Get the usage property: The usage property.
     * 
     * @return the usage value.
     */
    @Metadata(generated = true)
    public RunCompletionUsage getUsage() {
        return this.usage;
    }

    /**
     * Get the temperature property: The sampling temperature used for this run. If not set, defaults to 1.
     * 
     * @return the temperature value.
     */
    @Metadata(generated = true)
    public Double getTemperature() {
        return this.temperature;
    }

    /**
     * Get the topP property: The nucleus sampling value used for this run. If not set, defaults to 1.
     * 
     * @return the topP value.
     */
    @Metadata(generated = true)
    public Double getTopP() {
        return this.topP;
    }

    /**
     * Get the maxPromptTokens property: The maximum number of prompt tokens specified to have been used over the course
     * of the run.
     * 
     * @return the maxPromptTokens value.
     */
    @Metadata(generated = true)
    public Integer getMaxPromptTokens() {
        return this.maxPromptTokens;
    }

    /**
     * Get the maxCompletionTokens property: The maximum number of completion tokens specified to have been used over
     * the course of the run.
     * 
     * @return the maxCompletionTokens value.
     */
    @Metadata(generated = true)
    public Integer getMaxCompletionTokens() {
        return this.maxCompletionTokens;
    }

    /**
     * Get the truncationStrategy property: The truncation_strategy property.
     * 
     * @return the truncationStrategy value.
     */
    @Metadata(generated = true)
    public TruncationObject getTruncationStrategy() {
        return this.truncationStrategy;
    }

    /**
     * Get the toolChoice property: The tool_choice property.
     * 
     * @return the toolChoice value.
     */
    @Metadata(generated = true)
    public BinaryData getToolChoice() {
        return this.toolChoice;
    }

    /**
     * Get the parallelToolCalls property: The parallel_tool_calls property.
     * 
     * @return the parallelToolCalls value.
     */
    @Metadata(generated = true)
    public boolean isParallelToolCalls() {
        return this.parallelToolCalls;
    }

    /**
     * Get the responseFormat property: The response_format property.
     * 
     * @return the responseFormat value.
     */
    @Metadata(generated = true)
    public BinaryData getResponseFormat() {
        return this.responseFormat;
    }

    /**
     * {@inheritDoc}
     */
    @Metadata(generated = true)
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("id", this.id);
        jsonWriter.writeStringField("object", this.object);
        jsonWriter.writeLongField("created_at", this.createdAt);
        jsonWriter.writeStringField("thread_id", this.threadId);
        jsonWriter.writeStringField("assistant_id", this.assistantId);
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeJsonField("required_action", this.requiredAction);
        jsonWriter.writeJsonField("last_error", this.lastError);
        jsonWriter.writeNumberField("expires_at", this.expiresAt);
        jsonWriter.writeNumberField("started_at", this.startedAt);
        jsonWriter.writeNumberField("cancelled_at", this.cancelledAt);
        jsonWriter.writeNumberField("failed_at", this.failedAt);
        jsonWriter.writeNumberField("completed_at", this.completedAt);
        jsonWriter.writeJsonField("incomplete_details", this.incompleteDetails);
        jsonWriter.writeStringField("model", this.model);
        jsonWriter.writeStringField("instructions", this.instructions);
        jsonWriter.writeArrayField("tools", this.tools, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeMapField("metadata", this.metadata, (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("usage", this.usage);
        jsonWriter.writeNumberField("max_prompt_tokens", this.maxPromptTokens);
        jsonWriter.writeNumberField("max_completion_tokens", this.maxCompletionTokens);
        jsonWriter.writeJsonField("truncation_strategy", this.truncationStrategy);
        jsonWriter.writeUntypedField("tool_choice", this.toolChoice.toObject(Object.class));
        jsonWriter.writeBooleanField("parallel_tool_calls", this.parallelToolCalls);
        jsonWriter.writeUntypedField("response_format", this.responseFormat.toObject(Object.class));
        jsonWriter.writeNumberField("temperature", this.temperature);
        jsonWriter.writeNumberField("top_p", this.topP);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RunObject from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of RunObject if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the RunObject.
     */
    @Metadata(generated = true)
    public static RunObject fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String id = null;
            OffsetDateTime createdAt = null;
            String threadId = null;
            String assistantId = null;
            RunObjectStatus status = null;
            RunObjectRequiredAction requiredAction = null;
            RunObjectLastError lastError = null;
            OffsetDateTime expiresAt = null;
            OffsetDateTime startedAt = null;
            OffsetDateTime cancelledAt = null;
            OffsetDateTime failedAt = null;
            OffsetDateTime completedAt = null;
            RunObjectIncompleteDetails incompleteDetails = null;
            String model = null;
            String instructions = null;
            List<AssistantToolDefinition> tools = null;
            Map<String, String> metadata = null;
            RunCompletionUsage usage = null;
            Integer maxPromptTokens = null;
            Integer maxCompletionTokens = null;
            TruncationObject truncationStrategy = null;
            BinaryData toolChoice = null;
            boolean parallelToolCalls = false;
            BinaryData responseFormat = null;
            Double temperature = null;
            Double topP = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    id = reader.getString();
                } else if ("created_at".equals(fieldName)) {
                    createdAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(reader.getLong()), ZoneOffset.UTC);
                } else if ("thread_id".equals(fieldName)) {
                    threadId = reader.getString();
                } else if ("assistant_id".equals(fieldName)) {
                    assistantId = reader.getString();
                } else if ("status".equals(fieldName)) {
                    status = RunObjectStatus.fromString(reader.getString());
                } else if ("required_action".equals(fieldName)) {
                    requiredAction = RunObjectRequiredAction.fromJson(reader);
                } else if ("last_error".equals(fieldName)) {
                    lastError = RunObjectLastError.fromJson(reader);
                } else if ("expires_at".equals(fieldName)) {
                    Long expiresAtHolder = reader.getNullable(JsonReader::getLong);
                    if (expiresAtHolder != null) {
                        expiresAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(expiresAtHolder), ZoneOffset.UTC);
                    }
                } else if ("started_at".equals(fieldName)) {
                    Long startedAtHolder = reader.getNullable(JsonReader::getLong);
                    if (startedAtHolder != null) {
                        startedAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(startedAtHolder), ZoneOffset.UTC);
                    }
                } else if ("cancelled_at".equals(fieldName)) {
                    Long cancelledAtHolder = reader.getNullable(JsonReader::getLong);
                    if (cancelledAtHolder != null) {
                        cancelledAt
                            = OffsetDateTime.ofInstant(Instant.ofEpochSecond(cancelledAtHolder), ZoneOffset.UTC);
                    }
                } else if ("failed_at".equals(fieldName)) {
                    Long failedAtHolder = reader.getNullable(JsonReader::getLong);
                    if (failedAtHolder != null) {
                        failedAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(failedAtHolder), ZoneOffset.UTC);
                    }
                } else if ("completed_at".equals(fieldName)) {
                    Long completedAtHolder = reader.getNullable(JsonReader::getLong);
                    if (completedAtHolder != null) {
                        completedAt
                            = OffsetDateTime.ofInstant(Instant.ofEpochSecond(completedAtHolder), ZoneOffset.UTC);
                    }
                } else if ("incomplete_details".equals(fieldName)) {
                    incompleteDetails = RunObjectIncompleteDetails.fromJson(reader);
                } else if ("model".equals(fieldName)) {
                    model = reader.getString();
                } else if ("instructions".equals(fieldName)) {
                    instructions = reader.getString();
                } else if ("tools".equals(fieldName)) {
                    tools = reader.readArray(reader1 -> AssistantToolDefinition.fromJson(reader1));
                } else if ("metadata".equals(fieldName)) {
                    metadata = reader.readMap(reader1 -> reader1.getString());
                } else if ("usage".equals(fieldName)) {
                    usage = RunCompletionUsage.fromJson(reader);
                } else if ("max_prompt_tokens".equals(fieldName)) {
                    maxPromptTokens = reader.getNullable(JsonReader::getInt);
                } else if ("max_completion_tokens".equals(fieldName)) {
                    maxCompletionTokens = reader.getNullable(JsonReader::getInt);
                } else if ("truncation_strategy".equals(fieldName)) {
                    truncationStrategy = TruncationObject.fromJson(reader);
                } else if ("tool_choice".equals(fieldName)) {
                    toolChoice
                        = reader.getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()));
                } else if ("parallel_tool_calls".equals(fieldName)) {
                    parallelToolCalls = reader.getBoolean();
                } else if ("response_format".equals(fieldName)) {
                    responseFormat
                        = reader.getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped()));
                } else if ("temperature".equals(fieldName)) {
                    temperature = reader.getNullable(JsonReader::getDouble);
                } else if ("top_p".equals(fieldName)) {
                    topP = reader.getNullable(JsonReader::getDouble);
                } else {
                    reader.skipChildren();
                }
            }
            RunObject deserializedRunObject = new RunObject(id, createdAt, threadId, assistantId, status,
                requiredAction, lastError, expiresAt, startedAt, cancelledAt, failedAt, completedAt, incompleteDetails,
                model, instructions, tools, metadata, usage, maxPromptTokens, maxCompletionTokens, truncationStrategy,
                toolChoice, parallelToolCalls, responseFormat);
            deserializedRunObject.temperature = temperature;
            deserializedRunObject.topP = topP;

            return deserializedRunObject;
        });
    }
}
