// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.openai.models;

import io.clientcore.core.annotation.Metadata;
import io.clientcore.core.annotation.TypeConditions;
import io.clientcore.core.json.JsonReader;
import io.clientcore.core.json.JsonSerializable;
import io.clientcore.core.json.JsonToken;
import io.clientcore.core.json.JsonWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.Map;

/**
 * The Batch model.
 */
@Metadata(conditions = { TypeConditions.IMMUTABLE })
public final class Batch implements JsonSerializable<Batch> {
    /*
     * The id property.
     */
    @Metadata(generated = true)
    private final String id;

    /*
     * The object type, which is always `batch`.
     */
    @Metadata(generated = true)
    private final String object = "batch";

    /*
     * The OpenAI API endpoint used by the batch.
     */
    @Metadata(generated = true)
    private final String endpoint;

    /*
     * The errors property.
     */
    @Metadata(generated = true)
    private BatchErrors errors;

    /*
     * The ID of the input file for the batch.
     */
    @Metadata(generated = true)
    private final String inputFileId;

    /*
     * The time frame within which the batch should be processed.
     */
    @Metadata(generated = true)
    private final String completionWindow;

    /*
     * The current status of the batch.
     */
    @Metadata(generated = true)
    private final BatchStatus status;

    /*
     * The ID of the file containing the outputs of successfully executed requests.
     */
    @Metadata(generated = true)
    private String outputFileId;

    /*
     * The ID of the file containing the outputs of requests with errors.
     */
    @Metadata(generated = true)
    private String errorFileId;

    /*
     * The Unix timestamp (in seconds) for when the batch was created.
     */
    @Metadata(generated = true)
    private final long createdAt;

    /*
     * The Unix timestamp (in seconds) for when the batch started processing.
     */
    @Metadata(generated = true)
    private Long inProgressAt;

    /*
     * The Unix timestamp (in seconds) for when the batch will expire.
     */
    @Metadata(generated = true)
    private Long expiresAt;

    /*
     * The Unix timestamp (in seconds) for when the batch started finalizing.
     */
    @Metadata(generated = true)
    private Long finalizingAt;

    /*
     * The Unix timestamp (in seconds) for when the batch was completed.
     */
    @Metadata(generated = true)
    private Long completedAt;

    /*
     * The Unix timestamp (in seconds) for when the batch failed.
     */
    @Metadata(generated = true)
    private Long failedAt;

    /*
     * The Unix timestamp (in seconds) for when the batch expired.
     */
    @Metadata(generated = true)
    private Long expiredAt;

    /*
     * The Unix timestamp (in seconds) for when the batch started cancelling.
     */
    @Metadata(generated = true)
    private Long cancellingAt;

    /*
     * The Unix timestamp (in seconds) for when the batch was cancelled.
     */
    @Metadata(generated = true)
    private Long cancelledAt;

    /*
     * The request counts for different statuses within the batch.
     */
    @Metadata(generated = true)
    private BatchRequestCounts requestCounts;

    /*
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional
     * information about the object in a structured format. Keys can be a maximum of 64 characters long and values can
     * be a maximum of 512 characters long.
     */
    @Metadata(generated = true)
    private Map<String, String> metadata;

    /**
     * Creates an instance of Batch class.
     * 
     * @param id the id value to set.
     * @param endpoint the endpoint value to set.
     * @param inputFileId the inputFileId value to set.
     * @param completionWindow the completionWindow value to set.
     * @param status the status value to set.
     * @param createdAt the createdAt value to set.
     */
    @Metadata(generated = true)
    private Batch(String id, String endpoint, String inputFileId, String completionWindow, BatchStatus status,
        OffsetDateTime createdAt) {
        this.id = id;
        this.endpoint = endpoint;
        this.inputFileId = inputFileId;
        this.completionWindow = completionWindow;
        this.status = status;
        if (createdAt == null) {
            this.createdAt = 0L;
        } else {
            this.createdAt = createdAt.toEpochSecond();
        }
    }

    /**
     * Get the id property: The id property.
     * 
     * @return the id value.
     */
    @Metadata(generated = true)
    public String getId() {
        return this.id;
    }

    /**
     * Get the object property: The object type, which is always `batch`.
     * 
     * @return the object value.
     */
    @Metadata(generated = true)
    public String getObject() {
        return this.object;
    }

    /**
     * Get the endpoint property: The OpenAI API endpoint used by the batch.
     * 
     * @return the endpoint value.
     */
    @Metadata(generated = true)
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * Get the errors property: The errors property.
     * 
     * @return the errors value.
     */
    @Metadata(generated = true)
    public BatchErrors getErrors() {
        return this.errors;
    }

    /**
     * Get the inputFileId property: The ID of the input file for the batch.
     * 
     * @return the inputFileId value.
     */
    @Metadata(generated = true)
    public String getInputFileId() {
        return this.inputFileId;
    }

    /**
     * Get the completionWindow property: The time frame within which the batch should be processed.
     * 
     * @return the completionWindow value.
     */
    @Metadata(generated = true)
    public String getCompletionWindow() {
        return this.completionWindow;
    }

    /**
     * Get the status property: The current status of the batch.
     * 
     * @return the status value.
     */
    @Metadata(generated = true)
    public BatchStatus getStatus() {
        return this.status;
    }

    /**
     * Get the outputFileId property: The ID of the file containing the outputs of successfully executed requests.
     * 
     * @return the outputFileId value.
     */
    @Metadata(generated = true)
    public String getOutputFileId() {
        return this.outputFileId;
    }

    /**
     * Get the errorFileId property: The ID of the file containing the outputs of requests with errors.
     * 
     * @return the errorFileId value.
     */
    @Metadata(generated = true)
    public String getErrorFileId() {
        return this.errorFileId;
    }

    /**
     * Get the createdAt property: The Unix timestamp (in seconds) for when the batch was created.
     * 
     * @return the createdAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCreatedAt() {
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.createdAt), ZoneOffset.UTC);
    }

    /**
     * Get the inProgressAt property: The Unix timestamp (in seconds) for when the batch started processing.
     * 
     * @return the inProgressAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getInProgressAt() {
        if (this.inProgressAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.inProgressAt), ZoneOffset.UTC);
    }

    /**
     * Get the expiresAt property: The Unix timestamp (in seconds) for when the batch will expire.
     * 
     * @return the expiresAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getExpiresAt() {
        if (this.expiresAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.expiresAt), ZoneOffset.UTC);
    }

    /**
     * Get the finalizingAt property: The Unix timestamp (in seconds) for when the batch started finalizing.
     * 
     * @return the finalizingAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getFinalizingAt() {
        if (this.finalizingAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.finalizingAt), ZoneOffset.UTC);
    }

    /**
     * Get the completedAt property: The Unix timestamp (in seconds) for when the batch was completed.
     * 
     * @return the completedAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCompletedAt() {
        if (this.completedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.completedAt), ZoneOffset.UTC);
    }

    /**
     * Get the failedAt property: The Unix timestamp (in seconds) for when the batch failed.
     * 
     * @return the failedAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getFailedAt() {
        if (this.failedAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.failedAt), ZoneOffset.UTC);
    }

    /**
     * Get the expiredAt property: The Unix timestamp (in seconds) for when the batch expired.
     * 
     * @return the expiredAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getExpiredAt() {
        if (this.expiredAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.expiredAt), ZoneOffset.UTC);
    }

    /**
     * Get the cancellingAt property: The Unix timestamp (in seconds) for when the batch started cancelling.
     * 
     * @return the cancellingAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCancellingAt() {
        if (this.cancellingAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.cancellingAt), ZoneOffset.UTC);
    }

    /**
     * Get the cancelledAt property: The Unix timestamp (in seconds) for when the batch was cancelled.
     * 
     * @return the cancelledAt value.
     */
    @Metadata(generated = true)
    public OffsetDateTime getCancelledAt() {
        if (this.cancelledAt == null) {
            return null;
        }
        return OffsetDateTime.ofInstant(Instant.ofEpochSecond(this.cancelledAt), ZoneOffset.UTC);
    }

    /**
     * Get the requestCounts property: The request counts for different statuses within the batch.
     * 
     * @return the requestCounts value.
     */
    @Metadata(generated = true)
    public BatchRequestCounts getRequestCounts() {
        return this.requestCounts;
    }

    /**
     * Get the metadata property: Set of 16 key-value pairs that can be attached to an object. This can be useful for
     * storing additional information about the object in a structured format. Keys can be a maximum of 64 characters
     * long and values can be a maximum of 512 characters long.
     * 
     * @return the metadata value.
     */
    @Metadata(generated = true)
    public Map<String, String> getMetadata() {
        return this.metadata;
    }

    /**
     * {@inheritDoc}
     */
    @Metadata(generated = true)
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("id", this.id);
        jsonWriter.writeStringField("object", this.object);
        jsonWriter.writeStringField("endpoint", this.endpoint);
        jsonWriter.writeStringField("input_file_id", this.inputFileId);
        jsonWriter.writeStringField("completion_window", this.completionWindow);
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeLongField("created_at", this.createdAt);
        jsonWriter.writeJsonField("errors", this.errors);
        jsonWriter.writeStringField("output_file_id", this.outputFileId);
        jsonWriter.writeStringField("error_file_id", this.errorFileId);
        jsonWriter.writeNumberField("in_progress_at", this.inProgressAt);
        jsonWriter.writeNumberField("expires_at", this.expiresAt);
        jsonWriter.writeNumberField("finalizing_at", this.finalizingAt);
        jsonWriter.writeNumberField("completed_at", this.completedAt);
        jsonWriter.writeNumberField("failed_at", this.failedAt);
        jsonWriter.writeNumberField("expired_at", this.expiredAt);
        jsonWriter.writeNumberField("cancelling_at", this.cancellingAt);
        jsonWriter.writeNumberField("cancelled_at", this.cancelledAt);
        jsonWriter.writeJsonField("request_counts", this.requestCounts);
        jsonWriter.writeMapField("metadata", this.metadata, (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Batch from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Batch if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Batch.
     */
    @Metadata(generated = true)
    public static Batch fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String id = null;
            String endpoint = null;
            String inputFileId = null;
            String completionWindow = null;
            BatchStatus status = null;
            OffsetDateTime createdAt = null;
            BatchErrors errors = null;
            String outputFileId = null;
            String errorFileId = null;
            Long inProgressAt = null;
            Long expiresAt = null;
            Long finalizingAt = null;
            Long completedAt = null;
            Long failedAt = null;
            Long expiredAt = null;
            Long cancellingAt = null;
            Long cancelledAt = null;
            BatchRequestCounts requestCounts = null;
            Map<String, String> metadata = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    id = reader.getString();
                } else if ("endpoint".equals(fieldName)) {
                    endpoint = reader.getString();
                } else if ("input_file_id".equals(fieldName)) {
                    inputFileId = reader.getString();
                } else if ("completion_window".equals(fieldName)) {
                    completionWindow = reader.getString();
                } else if ("status".equals(fieldName)) {
                    status = BatchStatus.fromString(reader.getString());
                } else if ("created_at".equals(fieldName)) {
                    createdAt = OffsetDateTime.ofInstant(Instant.ofEpochSecond(reader.getLong()), ZoneOffset.UTC);
                } else if ("errors".equals(fieldName)) {
                    errors = BatchErrors.fromJson(reader);
                } else if ("output_file_id".equals(fieldName)) {
                    outputFileId = reader.getString();
                } else if ("error_file_id".equals(fieldName)) {
                    errorFileId = reader.getString();
                } else if ("in_progress_at".equals(fieldName)) {
                    inProgressAt = reader.getNullable(JsonReader::getLong);
                } else if ("expires_at".equals(fieldName)) {
                    expiresAt = reader.getNullable(JsonReader::getLong);
                } else if ("finalizing_at".equals(fieldName)) {
                    finalizingAt = reader.getNullable(JsonReader::getLong);
                } else if ("completed_at".equals(fieldName)) {
                    completedAt = reader.getNullable(JsonReader::getLong);
                } else if ("failed_at".equals(fieldName)) {
                    failedAt = reader.getNullable(JsonReader::getLong);
                } else if ("expired_at".equals(fieldName)) {
                    expiredAt = reader.getNullable(JsonReader::getLong);
                } else if ("cancelling_at".equals(fieldName)) {
                    cancellingAt = reader.getNullable(JsonReader::getLong);
                } else if ("cancelled_at".equals(fieldName)) {
                    cancelledAt = reader.getNullable(JsonReader::getLong);
                } else if ("request_counts".equals(fieldName)) {
                    requestCounts = BatchRequestCounts.fromJson(reader);
                } else if ("metadata".equals(fieldName)) {
                    metadata = reader.readMap(reader1 -> reader1.getString());
                } else {
                    reader.skipChildren();
                }
            }
            Batch deserializedBatch = new Batch(id, endpoint, inputFileId, completionWindow, status, createdAt);
            deserializedBatch.errors = errors;
            deserializedBatch.outputFileId = outputFileId;
            deserializedBatch.errorFileId = errorFileId;
            deserializedBatch.inProgressAt = inProgressAt;
            deserializedBatch.expiresAt = expiresAt;
            deserializedBatch.finalizingAt = finalizingAt;
            deserializedBatch.completedAt = completedAt;
            deserializedBatch.failedAt = failedAt;
            deserializedBatch.expiredAt = expiredAt;
            deserializedBatch.cancellingAt = cancellingAt;
            deserializedBatch.cancelledAt = cancelledAt;
            deserializedBatch.requestCounts = requestCounts;
            deserializedBatch.metadata = metadata;

            return deserializedBatch;
        });
    }
}
